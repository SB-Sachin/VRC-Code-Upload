/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       sachinbeniwal                                             */
/*    Created:      11/8/2025, 11:08:40 AM                                    */
/*    Description:  V5 Competition Project                                    */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
#include "vex.h"
#include <cmath>

using namespace vex;

// A global instance of competition
competition Competition;

// Global devices
vex::brain Brain;
motor leftMotor = motor(PORT3, true);
motor leftMotor2 = motor(PORT1, false);
motor leftMotor3 = motor(PORT2, true);
motor rightMotor = motor(PORT13, false);
motor rightMotor2 = motor(PORT11, false);
motor rightMotor3 = motor(PORT12, true);
inertial gyro_1 = inertial(PORT19);
motor intake = motor(PORT10, true);
motor deposition = motor(PORT9, true);
controller cont = controller();
digital_out toungePos = digital_out(Brain.ThreeWirePort.G);
digital_out wingPneumatics = digital_out(Brain.ThreeWirePort.H);


bool toungeUp = false; // State variable for tounge position
bool lastButtonAState = false; // State variable for ButtonX to detect single presses
bool wingUp = false; // State variable for wing pneumatics position
bool lastButtonBState = false; // State variable for ButtonA to detect single presses

// Constants for autonomous
const int DRIVE_SPEED = 10; // Base speed for driving
const int AUTON_DRIVE_SPEED = 20; // Speed for autonomous movements

// Constants for driver control
const double DRIVER_SPEED = 0.7; // Speed multiplier for driver control
const double TURN_SPEED = 0.3; // Speed multiplier for turning (slower than forward)


//------------------- Cubic Acceleration Function -------------------//

int sgn(double val) {
    if (val > 0) return 1;
    if (val < 0) return -1;
    return 0;
}

double applyCubicCurve(double input) {
  // Input range: -100 to 100
  // Output range: -100 to 100

  double normalized = fabs(input) / 100.0;

  // Make sure the exponent is a double so 10/3 becomes ~3.3333
  double absolute_value_part = pow(normalized, 10.0 / 3.0);

  // Multiply the sign by the curved magnitude
  double curved = sgn(input) * absolute_value_part;

  return curved * 100.0;
}


//------------------- Motor Control Helper Functions -------------------//

void setAllMotors(directionType dir, double speed, percentUnits units) {
  leftMotor.spin(dir, speed, units);
  leftMotor2.spin(dir, speed, units);
  leftMotor3.spin(dir, speed, units);
  rightMotor.spin(dir, speed, units);
  rightMotor2.spin(dir, speed, units);
  rightMotor3.spin(dir, speed, units);
}

void stopAllMotors(brakeType mode = brake) {
  leftMotor.stop(mode);
  leftMotor2.stop(mode);
  leftMotor3.stop(mode);
  rightMotor.stop(mode);
  rightMotor2.stop(mode);
  rightMotor3.stop(mode);
  intake.stop(mode);
  deposition.stop(mode);
}

void resetAllMotorPositions() {
  leftMotor.setPosition(0, degrees);
  leftMotor2.setPosition(0, degrees);
  leftMotor3.setPosition(0, degrees);
  rightMotor.setPosition(0, degrees);
  rightMotor2.setPosition(0, degrees);
  rightMotor3.setPosition(0, degrees);
}

void setLeftMotors(directionType dir, double speed, percentUnits units) {
  leftMotor.spin(dir, speed, units);
  leftMotor2.spin(dir, speed, units);
  leftMotor3.spin(dir, speed, units);
}

void setRightMotors(directionType dir, double speed, percentUnits units) {
  rightMotor.spin(dir, speed, units);
  rightMotor2.spin(dir, speed, units);
  rightMotor3.spin(dir, speed, units);
}

//------------------- Helper Functions -------------------//

double wrapAngle(double angle) {
  while (angle >= 360) angle -= 360;
  while (angle < 0) angle += 360;
  return angle;
}

//------------------- Autonomous Drive Functions -------------------//

void drive_forward(int targetDegrees, bool runIntake = false, bool runDepo = false) {
  bool isBackward = targetDegrees < 0;
  int absDegrees = abs(targetDegrees);
  
  resetAllMotorPositions();

  while (fabs(leftMotor.position(degrees)) < absDegrees) {
    if (isBackward) {
      setAllMotors(reverse, AUTON_DRIVE_SPEED, pct);
    } else {
      setAllMotors(forward, AUTON_DRIVE_SPEED, pct);
    }

    if (runIntake) {
      intake.spin(forward, 100, pct);
    }
    if (runDepo) {
      deposition.spin(forward, 100, pct);
    }
    
    wait(20, msec);
  }

  stopAllMotors();
}

//------------------- Smart Turn Function -------------------//

void turn(double targetHeading, int intakeSpeed = 0) {
  double kp = 0.5;
  double maxSpeed = AUTON_DRIVE_SPEED;

  targetHeading = wrapAngle(targetHeading);

  // Start intake motor if intakeSpeed is provided
  if (intakeSpeed != 0) {
    intake.spin(forward, intakeSpeed, pct);
  }

  while (fabs(gyro_1.heading(degrees) - targetHeading) > 2.0) {
    double current = gyro_1.heading(degrees);
    double error = targetHeading - current;

    // Wrap error for shortest path
    if (error > 180) error -= 360;
    if (error < -180) error += 360;

    double speed = error * kp;

    // Clamp speed
    if (speed > maxSpeed) speed = maxSpeed;
    if (speed < -maxSpeed) speed = -maxSpeed;

    setLeftMotors(forward, speed, pct);
    setRightMotors(reverse, speed, pct);

    wait(20, msec);
  }

  stopAllMotors();
  intake.stop(brake); // Stop intake motor after turning
}

//------------------- Turn Wrappers -------------------//

void drive_turn_right_no_hands(double degreesToTurn, int intakeSpeed = 0) {
  double target = wrapAngle(gyro_1.heading(degrees) + fabs(degreesToTurn));
  turn(target, intakeSpeed);
}

void drive_turn_left_no_hands(double degreesToTurn, int intakeSpeed = 0) {
  double target = wrapAngle(gyro_1.heading(degrees) - fabs(degreesToTurn));
  turn(target, intakeSpeed);
}

//------------------- Driver Control Functions -------------------//

void split_Drive() {
    // Get raw joystick values (-100 to 100)
    double forwardRaw = cont.Axis3.position();
    double turnRaw = cont.Axis1.position();
    
    // Apply cubic acceleration curve to both axes
    double forwardCurved = applyCubicCurve(forwardRaw);
    double turnCurved = applyCubicCurve(turnRaw);
    
    // Apply speed multipliers
    double forward = forwardCurved * DRIVER_SPEED;
    double turn = turnCurved * TURN_SPEED;
    
    // Calculate target speeds
    double targetLeftSpeed = forward + turn;
    double targetRightSpeed = forward - turn;
    
    // Set motors directly to target speeds (no acceleration limiting)
    setLeftMotors(vex::forward, targetLeftSpeed, pct);
    setRightMotors(vex::forward, targetRightSpeed, pct);
    
    // Tongue position control (toggle with ButtonA)
    bool currentButtonAState = cont.ButtonA.pressing();
    if (currentButtonAState && !lastButtonAState) {
        toungeUp = !toungeUp;
        toungePos.set(toungeUp);
    }
    lastButtonAState = currentButtonAState;

    // Wing pneumatics control (toggle with ButtonB)
    bool currentButtonBState = cont.ButtonB.pressing();
    if (currentButtonBState && !lastButtonBState) {
        wingUp = !wingUp;
        wingPneumatics.set(wingUp);
    }
    lastButtonBState = currentButtonBState;
    
    // Intake control
    if(cont.ButtonL1.pressing()) {
        intake.spin(vex::forward, 100, pct);
    } else if(cont.ButtonL2.pressing()) {
        intake.spin(vex::forward, -100, pct);
    } else {
        intake.stop();
    }
    
    // Deposition control
    if(cont.ButtonR1.pressing()) {
        deposition.spin(vex::forward, 60, pct);
    } else if(cont.ButtonR2.pressing()) {
        deposition.spin(vex::forward, -60, pct);
    } else {
        deposition.stop();
    }
}


void intakeAndDepo(double timeSec, int intakeSpeed, int depoSpeed) {
  intake.spin(forward, intakeSpeed, pct);
  deposition.spin(forward, depoSpeed, pct);
  wait(timeSec, sec);
  intake.stop(brake);
  deposition.stop(brake);
}

//------------------- Debug Display -------------------//

void brainDisplay() {
  while (true) {
    Brain.Screen.clearScreen();
    Brain.Screen.printAt(1, 40, "LeftMotor: %.2f", leftMotor.position(degrees));
    Brain.Screen.printAt(1, 60, "RightMotor: %.2f", rightMotor.position(degrees));
    Brain.Screen.printAt(1, 80, "gyro_1 Rotation: %.2f", gyro_1.rotation(degrees));
    Brain.Screen.printAt(1, 100, "Heading: %.2f", gyro_1.heading(degrees));
    wait(100, msec);
  }
}

//------------------- Autonomous Routines -------------------//

void auton_right_side() {
  // RIGHT SIDE autonomous routine
  gyro_1.setHeading(34, degrees);

  drive_forward(470.1, true);      // Drive forward with intake (degrees)
  turn(45, 100);                  // Turn RIGHT 25 degrees
  // drive_forward(235.1, true);       // Drive forward (degrees   // Drive forward (degrees)
  // drive_forward(-235.1, true);
  turn(0);
  drive_forward(-160);
  turn(-90);
  drive_forward(-450.1);
  turn(180);
  drive_forward(-235.1);

  toungePos.set(true);
  drive_forward(100, true);
  drive_forward(-470.1, true);
  intakeAndDepo(10, 50, 50);
}

void auton_left_side() {
  gyro_1.setHeading(0, degrees);
  
  drive_forward(1200, true);       // Drive forward with intake (degrees)
  turn(335, 100);                  // Turn LEFT 25 degrees (360 - 25 = 335)
  drive_forward(300, true);        // Drive forward (degrees)
  turn(315, 100);                  // Turn LEFT to 315 degrees total (360 - 45 = 315)
  drive_forward(1200, true);       // Drive forward (degrees)
  drive_forward(-900, true);       // Move away from auton line
}


/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*---------------------------------------------------------------------------*/

void pre_auton(void) {
  // Calibrate gyro at startup
  Brain.Screen.printAt(10, 200, "Calibrating Gyro...");
  gyro_1.calibrate();
  while (gyro_1.isCalibrating()) {
    wait(100, msec);
  }
  Brain.Screen.printAt(10, 220, "Gyro Ready!");
}

/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*---------------------------------------------------------------------------*/

void autonomous(void) {
  // Run selected autonomous routine
  auton_right_side();
}

/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*---------------------------------------------------------------------------*/

void usercontrol(void) {
  // Start debug display thread
  thread t(brainDisplay);
  
  // User control code here, inside the loop
  while (1) {
    split_Drive();
    
    wait(10, msec);
  }
}


int main() {
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);

  pre_auton();

  while (true) {
    wait(100, msec);
  }
}
